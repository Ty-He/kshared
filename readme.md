# 1 前端初步构建

网页由三部分构成：*模板部分，特定组件，内容*；

这里先写一组静态网页，然后考虑模板替换；

前后端交互的话先前crub示例已经接触过，再做起来就比较简单了。

## note基本显示

包括以下两个函数：

* **`getfile()`**
  * 用`fetch()`像服务端请求md文件，接收后使用`marked`进行渲染；

* **`generate_toc`**
  * 根据转换后的结果，寻找h(1, 2, 3)标签生成TOC(Table Of Content)

## 索引项

对于article存储，采用分开存储的方案：内容使用文件系统存储，相关信息使用数据库存储：
  * 数据库存储结构化数据，便于搜索和管理。
  * 文件系统存储实际内容，易于编辑和备份。
考虑每一个记录具体包含的字段
  * title 标题
  * ahthor_id 作者
  * update_time 更新时间
  * type 分类
  * label 标签

这里考虑了一下，将分类与标签分离，分类相对更宽泛，标签描述更细致

比如: asio.md 
  * type: C++ network
  * label: (C++ network) aysnc callback co-routinue tcp concurrent event_look epoll iocp等等

用户表：
  * id
  * name

评论表
  * id
  * user_id
  * article_id
  * content
  * time

### 小结

终于差不多把前端页面的框架搭好了，主要包括两个页面：

  1. 主页，包含banner、缩略图、最新内容
  2. article详情页，包含article内容、对应目录

接下来写前后端交互的article查询。

# 2 前端请求article

## 请求article列表

进入主页时，会请求最新的5个article，应**在<a>的herf字段中使用模板替换查询字符串**，这样，在点击链接时会发送响应的请求。

进入分类页(当前未实现)，应按请求某一分类所有的article列表，这里可以考虑做分页，但不会是现在。

因为是动态网站，所以要考虑**自定义添加分类**，前面的分类都是预定义的，这里考虑在导航栏中添加一个分类，进入后显示所有分类的前若干篇文章，不宜在首页显示过多的分类。

## 持久化存储

### 数据库

新建一个`kshared`数据库，创建以下表

* article
  * **id**(uint32)
  * title(string)
  * type(string)
  * label(string)
  * release_time(time.Time)
  * update_time(time.Time)
  * *author_id*(uint32)

* author
  * **id**
  * name
  * ...

* comment
  * **id**
  * content
  * time
  * *author_id*

* has_comments
  * article_id
  * comment_id


* 新建数据库
```sh
mysql -uroot -p
create database kshared;
```

* 创建数据库

这部分代码比较多，在终端写比较麻烦，这里创建一个.sql文件。

这里先集中核心功能，也就是前两张表。

### 文件系统

`article`表中每一条记录对应服务器端文件系统中的一个md文件；

md文件的名字与主键一致。


## 请求具体article

这里和之前静态页面有有些区别，原因在于从go-server中读出文件后，需要动态替换到模板中；

这时候替换的仅仅是md的源码文件，需要渲染出html的格式；

而之前的方案又是在js端完成渲染，这就导致了客户端会略微停顿一会:

在加载完服务器响应的html后，需要执行`window.onload`注册的方法；

这样看来，似乎在服务端实现渲染是是更好的选择。

***

可是我并不像在go中引入过多的外部库，因此通过可见性与调用时机的改善一下客户端
  * 可见性: 不希望md源码显示给用户，因为未完成渲染时给添加类名`.invisible`
  * 调用时机: `documuent.Add...`比`window.onload`更合适

这里不小心又发现了一个问题：

md代码块中为html时，`marked`似乎不能很好的渲染；

这可能与html中标签对有联系，不过我这里不想深究这些小细节(暂时记为TODO(已完成))。

另外，这里希望*目录固定在视口中*，不会因为滚到底部就看不到目录了；

此外，目录可能很长，因此需要给目录添加滚动条。

***

到这里，在完成一个分类页面，基本就是先了一个简单的静态文件服务器。

# 3 完善静态文件服务器

不着急，明天先上一节操作系统。

## 目录固定定位 + 滚动条

定位定了好久，最终得到了一个解决方案：

以设计的布局如下:
```sh
|content(8*col)|empty(1*col)|toc(3*col)|
```

如果直接对toc进行固定定位，它会基于当前的`row`进行固定；

虽然我们仍然可以offset/push进行右移，但是它吗的好巧不巧；

多一个格子太靠右，少一个格子太靠左；

解决方案是：在toc所在的div再用一个div包裹内容，让它进行固定定位

顺便美化了一下滚动条，当然其实也不好看

## 分类页面

分类和归档，我的理解是分类是某一种分类，而归档是所有分类：

> “归档”指的是将文件、记录或数据整理并保存到特定的存储介质中，以便于未来的检索和管理。它通常用于保存不再频繁使用但仍需保留的重要信息。这有助于清理现有系统，同时确保数据的长期安全和可访问性。归档可以是数字化的，也可以是纸质的。

这里给**归档**设计为按时间排序，给分类显示所有分类；

分类应显示各个分类下最新的若干条内容，最后一条查看该分类下的全部内容；

* 分类是否被添加？分类是否单独成表？

我的想法是分类可以被添加，它作为信息记录的一个字段，并没有给它过多的限制；至于单独成表，会很麻烦，而我只想通过考核。

分类的添加不应该被无限设计，我的想法是所有分类连同一些常量定义放到一个全局配置模块中。

单个分类域的实现完全可以使用*主页->最新内容*表示，这里不再设计；

又会产生一个问题：

归档会有很多的条目，如果以后拓展到多用户，那么一次加载的内容就会很多，所以这里应该做**MySQL分页查询**。

先去学一波。

## 修改一下导航拦截

这些链接的小事，先不用管。

## Bug

markdown文件中的标签会于服务器响应的html页面中的标签错误组合;

有点类似sql注入，采用错误的匹配方式... 我操了真是

最终还是妥协了，改成两次请求:
  1. 首先请求html页面，此时内容显示加载中之类的提示语
  2. 然后异步请求md文件，然后进行解析

客户端请求article page，响应的article page不应还直接显示，而是做一次转发。

好，基本上搞定了md里面有标签的问题。

web端二次请求md文件时，给加了一个加载动画，来自：<https://juejin.cn/post/7020064738956705823>

很好看，但实际上网络传输也是很快的。只是说相比于其它操作的开销大一些。


# 4 用户系统

## web-server如何分辨不同的用户？

最简单也是很傻逼的方式就是在查询字符串中添加用户id和pwd，肯定是不可取的，太不安全，就算行外人也懂。


其次是考虑一些http的验证字段，可是客户端的大部分请求逻辑都是浏览器的默认行为，这样的化就要重写很多逻辑，也会带来不必要的麻烦，pass


以下是chatgpt提供的解决方案：

> 区分用户的常用方法有：

> 1. **Cookie**：在用户浏览器中存储一个唯一的标识符，每次请求时发送回服务器。
> 2. **Session**：服务器端存储用户会话信息，并在每次请求中通过一个唯一的Session ID来识别用户。
> 3. **Token**：如JWT（JSON Web Token），用户登录后获取一个包含用户信息的Token，每次请求时将Token放在请求头中发送。
> 4. **IP地址**：虽然不总是可靠，但可以作为辅助手段。

由于kshared服务端是使用`net/http`构建的，而此包不提供直接支持Session和Token，因此我此处也就不考虑了，毕竟这些对外来说几乎是新东西了。

## Cookie

* Cookie是什么？(简单理解)

Cookie是http协议的一部分，Cookie是http数据包中的一段信息，它有若干个字段，其中我们可以使用其中的某些字段(`Value`)来绑定底层db中的某条用户记录。

Cookie由服务端设置：
```go
func SetCookie(w ResponseWriter, cookie *Cookie)
```

当客户端接收到一个带有Cookie的响应时，在以后的请求中，都会自动携带这个请求，当这个Cookie过期后(由服务端设置`Expire`字段)，会自动删除，这时服务端应该要求客户端重新登录。


* 详细解析

你的理解是对的，Cookie确实是一种在HTTP协议中传递的小段信息，但它在Web开发中的作用很重要。以下是对Cookie的中文含义和功能的详细解释：

### 什么是Cookie？

**Cookie** 是一个由服务器发送到客户端（通常是浏览器）的数据包，客户端在随后的请求中会将这个数据包带回服务器。它是一种在客户端存储少量数据的机制，用于保持状态信息或在多个请求之间传递信息。

### Cookie的主要作用

1. **状态管理**：
   - **会话管理**：Cookie可以用来保存用户的登录状态、购物车内容、用户偏好等信息，使得用户在访问同一网站时能够保持这些状态信息。
   - **会话ID**：通过Cookie，服务器可以生成一个唯一的会话ID，存储在客户端，后续请求中通过这个ID来识别用户的会话。

2. **跟踪与个性化**：
   - **用户跟踪**：网站可以使用Cookie跟踪用户的访问行为，从而提供个性化的内容或广告。
   - **个性化设置**：用户可以通过Cookie保存个人设置和偏好，比如语言选择或主题设置。

### Cookie的组成部分

一个Cookie通常包含以下几个部分：

- **Name**：Cookie的名称。
- **Value**：Cookie的值。
- **Domain**：指定Cookie的有效域名。
- **Path**：指定Cookie的有效路径。
- **Expires/Max-Age**：指定Cookie的过期时间或有效期。
- **Secure**：指示Cookie是否只能通过HTTPS协议传输。
- **HttpOnly**：指示Cookie是否只能由HTTP协议访问，防止JavaScript访问。

### 总结

- **Cookie** 是HTTP协议中的一部分，用于在客户端存储少量数据。
- 它用于会话管理、跟踪用户活动和个性化用户体验。
- 虽然`net/http`包不直接提供会话管理或令牌功能，但它支持Cookie的设置和读取，可以用来实现这些功能。

理解Cookie的这些基本概念有助于你更好地处理Web应用中的状态管理和用户体验。

## `net/http`操作Cookie

1. 设置Cookie

```go
cookie := &http.Cookie {
  Name: "user_id", // 唯一，否则会覆盖先前重名Cookie(针对同一用户)
  Value: "1", // 绑定id
  Path: "/", // 有效路径，`/`表示所有路径有效
  Expires: time.Now().Add(24 * time.Hour),
}

// 写入响应
http.SetCookie(w, cookie);
```

2. 读取Cookie
```go
// 读出id的值，如果没有名字是user_id的Cookie，返回err
uid, err := r.Cookie("user_id");

// cookie并不会只有一个 不同用户间cookie相互独立
for _, cookie := range r.Cookies() {
  fmt.Printf("cookie name: %s, value: %s\n", cookie.Name, cook.Value);
}
```

## 添加用户系统

### `author`数据表

这里的用户对应底层数据表的author，author表目前只有id、name两个字段，在添加`pwd`和`email`字段

### 登录与注册界面

我不想太多的内容占据，参考bing搜索框旁边那玩意，我做了一个下拉菜单。

而登录和注册都通过Modal实现。

这里并不希望重写标签的请求逻辑，但是Modal的提交按钮在表单之外，

只需在js中通过dom找到表单然后执行上面的`submit()`函数即可。

### 前后端交互

这里梳理一下逻辑：

* Modal

封装author类，对应author表中的一条记录，author有如下方法：

  * `IsValid()`     验证`*this`是否合法
  * `Register()`    将`*this`插入到数据库

* controller
  
  * login
    * 读出表单数据
    * 执行`a.IsValid()`
    * 如果没出错，设置Cookie，执行`handleHome()`
  * register
    * 类似

* web
  * 用户下拉菜单和模态框都放在Layout模板中
  * 对应js文件也在layout模板中导入
  * 主要是一个按钮的点击事件，另外页面加载时会尝试读当前页面的Cookie，如果有，写出来。

###  思路整理

感觉思路好乱，到目前为止，两次提交，基本实现了一个比较完善的静态服务器。

先整理一下接下来要做什么，在制定具体的计划：

* 必选
  * 文件上传
  * 基本文章评论
  * 服务器优雅退出

* 可选
  * 提供删除指定文章的功能
  * 按标签搜索
  * 文章评论的回复

好像也没多少东西了，先做文件上传，省着我总用`scp`传文件

# 5 文件上传 file upload

## web端文件上传

这里之前用户栏里留了上传文件的链接，依旧采用先前登录的模式即可，

表单提交时接收一个文件和一个用户身份字段，一个用户不能给别人提交文件，

这里需要在前端做一下检验，一开始我指向用表单上传文件，但是这样无法知道作者

因此我们给表单多一个选项，用于填写用户身份，

每个用户应该填写自己的身份，因此该字段会在前端与cookie的值进行比对

如果未登录或是有意无意指定错误的author信息，提示错误。

***

每一个article记录里面还有几个字段需要用户填写：`title, type, label`

这些应该都是文本输入框，`title`和`label`的值可以是任意的，

但是`type`应是规定的分类之一(规定的分类可能扩展，因此我不打算做成下拉框，好麻烦)

TODO: `type`下拉框(不想写)

如果`type`做成文本框的话，后端则会根据配置信息验证它的值。

*** 

我操，真是写啥了，验证身份直接他吗的用**Cookie**不久行了吗，哎。



## 后端接收文件

其实就是一个读写文件的操作，但这里需要确定article和author的对应关系；

这两者显然是$n:1$的关系，这里先前已经预留了一个外键。

整体处理思路如下：

* Controller层(从Cookie和form中)读取用户传来的信息字段，然后构造一个支持更多操作的`article`对象
* 构造时检验参数的合法性，如果合法，控制权转由controller层
* Controller层继续读出客户端上传的文件，创建一个本地文件进行复制`io.Copy()`
* 之后控制端交回modal层插入这一条记录，并更新主键
* 返回controller，如果出错，删除文件；否则将文件名改为主键名

## 页面改善

* 下拉菜单

小按钮太突兀了，也会影响其它元素的位置，因此把它放到导航条最右侧位置。

我感觉还可以，不是很丑。

* 服务器响应

如果客户端请求不合法，我目前在服务端都是回复一个`BadRequest`的状态码，比较简单粗暴。

如果只是请求的话，这种方式没有什么问题，但是当前上传文件的操作是交互性比较强的，直接返回`BadRequst`有点太粗暴了。

但是我又不是很想重写表单的提交逻辑...

如果指向调用表单上的`submit()`是无法获取响应的，但自己写也不复杂：

```javascript
// form 是待提交的表单
const formData = new FormData(form);

let res = await fetch(this.action, {
  method: 'POST',
  body: formDate,
});

if (!res.ok) {
  // BadRequest 
  // Note User
  // ...
} else {
  // ok
}
```

但是麻烦的是，他骂了隔壁的每个`res`的两种情况都要单独处理，每个表单也都要写一套。

TODO: 交互式出错页面

## 预览

* 更新文件
* 删除文件
* 按标签搜索

想了一下，**评论**必须做，不做我写鸡儿，上面的东西都好做，暂时放一会。

# 6 文件更新&删除

## 更新

搞了一下neovim的主题，大白天的老是暗色主题看起来不舒服。

要进行文件的更新，前台发来的请求肯定要包含主键，而一开始请求是也是根据主键请求的，因此我们需要将这个主键保存起来。

在之前的方案中，服务器返回页面和对应文章的id，客户端在通过这个id构成query，进行内容的请求；

而现在，对该内容由更多的操作，因此这个`query`需要保存到全局。

***

在页面上，增加一个按钮和模态框，接收一个文件；

重写表达的提交事件，根据`query`的值动态查询。

这里借助自定义`query`会导致两个js文件耦合严重，其实通过js也可获取当前页面的查询字符串：
```
// 如果没有query为空字符串，query[0] = '?'
let query = window.location.search;
```

后端接收文件时也是类似之前文件上传的过程，这里不再赘述。

为了方便使用，我们将文件操作的内容抽象出一个模块，之前的临时文件的处理方法其实有bug：

我们收到一个文件，会将它先存储为一个临时文件`resoure/article/0.md`;

kshared显然是可以进行并发处理请求，如果多个上传文件请求同时来，就会导致内容都写到`0.md`这个文件中；

而且如果同时写还会造成一些乱序、缺页等行为。

因此我们抽象出一个`tempFile`类，应从它的`newTemp()`方法构造该对象，该类维护一个全局的`uint64`变量`filename`，

这个变量可以被多个`goroutine`安全的读写，每次读出一个值同时进行`++`操作

每次构造时，指定文件名为`sprintf("resource/article/-%u.md", filename)`，这样每个临时文件名全局唯一

此外，抽象了`copy(), save(), close()`方法；

对于`close()`，我希望实现如果句柄关闭时仍是临时文件，就删除它，否则只是关闭句柄。

## 删除

有了更新的实现，删除就更不值一提了，只需要一个按钮即可：

点击时获取查询字符串发送一个delete请求，服务器处理即可。

这里执行逻辑删除，设置`type`字段为`crash`，保留底层数据库记录。

首页和归档会显示最新的文章，因此需要查询时增加过滤条件。

为了方便使用，将这个删除的类型放到全局配置模块。

## 查询

感觉意义不大，先放一下，没啥屌用。


# 7 小结

现在基本已经实现**用户系统**和**增删改查**，其实也算完成了大半，接下来集中精力实现**评论系统**

在这之前，用已经实现的kshared多上传几个md，多操作一下，看看是不是有遗漏或优化的地方；

现在9.16，不用太着急。

感觉基本上也没啥问题，而且一个人测意义也不大。

要不直接提交了考虑评论去了。


# 8 评论系统

## 数据存储

* 已知：
  * 每个article有若干个评论*comment*
  * 每个评论有若干条回复*reply*
  * 每个回复也会有若干条回复

因此，一篇笔记的所有评论应该构成一个*树形数据结构*，具体来说应该是一片森林，

其中每棵树的根节点评论是直接回复笔记的评论。


对于根节点和非根节点，它们的区别是有没有父节点，由于这里使用的是关系型数据库而不是层次型的因此这时有两种解决方案：
  * 根节点一张表，非根节点一张表
  * 虚拟一个最顶级的结点，它的子节点是所有根节点

简单起见，还是虚拟根节点比较简单，这样可以用一张表描述所有评论。

* comment
  * id(uint32)
  * pid(uint32, if null, is root)
  * article_id(uint32)
  * sender_id(uint32)
  * content(string)
  * release(time.Time)

一些扩展字段：
  * is_read(bool) // 用于消息通知，但估计是没时间做这个了
  * is_removed(bool) // 删评
  * ip
  * thumbs up // 点赞
  * shared // 分享
  * reference // 引用

目标是至少搭建出一个骨架。

## web端请求

首先，我们一开始请求文章页面时不响应任何评论，只是添加一个置顶的系统消息。

每条评论(包括上面的系统评论)都有展开和回复两个按钮选项：

* 展开

展开后显示这个评论所有的回复，这里暂时没有做分页处理，分页可以减少网络传输的数据量，

但要做的话就只能用`offset`的方式分页，不会提高查询选项，这里暂时标记一下。

TODO: 请求评论分页

这个请求本质是一个GET请求，服务端需要知道是哪篇文章的评论`article_id`，以及父评论是哪一条`pid`，前者可以通过查询字符串获取，后者可以通过给元素设置的属性获取。

解析服务器响应的json数据后，遍历每一项，为一个创建一个评论标签。

* 回复

首先考虑回复是的文本框，有两种选择方案：
  1. 模态框Modal
  2. 动态地在评论树中创建

很显然1要简单得多，因为2还要考虑排版等问题。

但是1就丢失了局部性：我们将`comment_id`保存在li标签中，使用1完成跳转，就无法在提交时通过`parentElement`索引至li

不过这并不难解决，只需要在每次触发模态框时记录当前的按钮即可，发送时通过这个按钮向上索引。

对于comment表的一条记录，主键自增，sender_id在cookie中，release由服务器获取，

因此客户端只要提交pid，article_id和content即可:

pid是我们给`<li>`设置的`comment_id`属性，article_id在查询字符串中，`content`是`<textarea>`的`value`值。

将这三个构成一个对象，然后序列化成json字符串后发送POST请求即可。

这个请求只需检查是否ok即可，给予用于提示。

* **`fetch()`要不要捕获异常?**

我很多地方写`fetch()`都是没有`catch(error)`操作的，个人感觉`fetch()`出错就表明网络问题，

既然网络有问题也就代表客户端无法访问服务器了，这时不如直接崩溃，留着也没有。

当然，推荐的写法肯定是捕获喽。

## 服务端

处理请求，响应json数据即可：

首先在model层定义`comment`的结构，这里`comment`的操作比较少，所有就统一用一个`struct`：

想了一下还是不大合适：

对于插入新评论的操作，显然需要一个能描述一条`comment`记录中除主键外的所有字段；

对于响应评论的操作，则需要响应如下结构的列表：
```go
comment object
{ 
    id:         key
    sender:     the name of sender
    time:       the tmie of release
    content:    ...
    target:     recver name
}
```

但是定义两个结构感觉太小题大多了，因此可以返回一个`map[string]string`

### 插入新评论

这里在建表时突然发现，`pid`并不能满足外键定义，因为最顶级父节点时虚拟的。

这里的解决方案是采用*应用层增加处理逻辑*：在插入前，我们手动检查一个是否是一个合法外键：

```go
func (c *Comment) valid_ref() bool
```

返回true只有两种可能`pid == 0 || exist(pid)`

这里建表时已知提示语法错，猜测`release`应该是mysql中的一个保留字。

### 获取评论

此处query可能会比较复杂:

  1. 已知一条评论的`id`和`article_id`
  2. 获取这个评论`sender_id`从而获取发送者名字(也是子评论回复的目标)`target`，此时要注意评论是否存在，如果不存在(即为虚拟父节点)，则令`target = "article"`
  3. 获取这个评论的所有子评论


### 完善工作

1. `call_once()`

这里发现如果重复请求评论，它就会已知向下创建新的`<ul>`列表，而且每次请求的结果是一致的。

因此这里需要`fetchCommnet()`只调用一次，最简单的方式肯定是用一个全局变量记录调用次数，之前有个视频讲惰性函数，感觉会增加复杂度。

上述方案都是不正确的，因为我们有多个这个的按钮，要保证每个按钮触发最多一次：

正确的解决方案应该是处理函数`fetchComment()`调用后移除触发该事件的元素的`onclick`属性

```js
async function fetchComment(event) {
  // ...

  //
  event.target.parentElement.removeAttribute('on-click');
}
```

# 9 我也不知道要干什么？！

好像该做的也都做了...

今天把nvim的浮动终端折腾出来了，没有什么实质的进度。

## 评论markdown支持

宋体的代码狗都不看。

这个走起来也简单，因为评论和文章是在一个页面的，而前面我们已经在该页面引入了`marked`

另外为了容纳`marked.parse()`转换后的内容，需要将`<p>`修改为`<span>`

这个确实简单。

## katex支持

我的很多题解等等都用到了Katex，而marked不支持这个，

这个我不大想做，无非是多引入一个库。

## 遇事不决

Q: 做了一个简单的web应用，可以支持用户上传md文件，然后可以在浏览器端渲染显示，也支持文件的删除，更新，支持多用户，支持简单的评论，对上传的md文件进行了分类和归档，服务端用go的net/http实现，在此基础上，有什么推荐的可实现的扩展功能？

> 这个web应用的基础已经很不错了！你可以考虑添加以下扩展功能：

> 1. **实时协作编辑**：允许多用户同时编辑同一个md文件，并实时更新显示。
> 2. **标签系统**：为md文件添加标签，方便用户搜索和分类。
> 3. **版本控制**：记录文件的历史版本，允许用户查看和恢复之前的版本。
> 4. **导出功能**：支持将md文件导出为PDF或其他格式。
> 5. **用户权限管理**：设置不同级别的用户权限，控制文件的查看和编辑权限。
> 6. **通知系统**：当文件被评论或更新时，向相关用户发送通知。
> 7. **Markdown扩展支持**：支持更多Markdown扩展，如数学公式或图表。

> 你想要深入了解哪一个功能吗？

真是一语惊醒梦中人，我之前还给article记录留了一个label字段，这不就用上了。

这个**标签系统**是必做的，另外，我也挺想做**通知系统**。

看看时间吧，如果能把这两个玩意儿搞出来，估计就差不多了。

# 10 标签系统

这个简单，先做这个。

对于web端，直接请求一个带查询字符串的url即可。

服务端检索数据库，响应的页面可以用之前的归档页表示。

但是我们`label`字段设置的很有问题啊我去，这哪个傻逼想出来的用空格分割每个标签项，现在不好查了。

***

这个东西看起来好做，实际上要动我们的数据表。

做不做？做了感觉会花很多时间我日。

冲了，不就建两个破表吗？

***

## 建表

一个md文件可能由多个标签，一个标签下也可能由多个md文件，显然是多对多的关系

对于md文件，我们已建立`article`表

因此我们还需要一下两表：
   1. Tag
   2. ArticleTag

* Tag
  * id
  * name(唯一，英语小写)
* ArticleTag
  * article_id
  * tag_id

这些字段的含义相当显然，不做多余的解释了就。

## 更新

在插入一个新的article时，用户指定了若干标签，我们先前十分傻逼地存到一个label标签中，现在要做出修正。

1. 首先解析`total_lable`字符串，然后全部转小写，对于每一项，查看数据库中是否已有，如果没有，就插入；同时我们需要记录每一项的`tag_id`

2. 然后插入`artile`记录，这与先前是一样的

3. 最后插入若干条`article_tag`记录，记录其对应关系。

* 注意：
  * 以上操作由若干次的插入，为了保证数据一致性需要开始**事务**
  * 查询是否存在，插入若干项，都是同一sql换参之后的多次执行，需要进行**预处理**

这里写的思路很简单，实际上写起来还是很复杂的。


## 查询指定标签下的所有文章项

这个sql乍一写还不是很好写：

```sql
select filter_article.id, title, author.name, update_time 
from (
  select article.id, title, article.author_id, update_time
  from article
  where article.type != 'deleted' and article.id in (
    select article_id 
    from article_tag join tag on article_tag.tag_id = tag.id
    where tag.name = 'go'
  )
) filter_article 
join author on filter_article.author_id = author.id 
order by update_time desc;
```

这个写法类比写就简单了，前面查过所有的article和对应的作者名，

这里需要对查询的article做一个过滤操作，只查标签等于指定值(上述示例为`1`)的article

* 东西多了就容易遗漏，记录两个bug

1. 回滚多了但别忘记提交

2. 用户提交的`total_label`中的空格问题：

```go
s := "gnu cpp gcc linux-c gdb g++ "
for i, name := range strings.Split(s, " ") {
	fmt.Println(i, name)
}
```

上述解决方案在`s`以空格开头或结尾会获取到空字符串，这是不期望的；

正确的方法应该为`strings.Field(s)`

## 页面

首先要接收用户输入，然后响应html文件，前端应该使用js将替换到当前页面：
```js
const html = await res.text();

document.open();
document.write(html);
document.close();
```


# 11 简单的通知功能

这里实现一个**简单**的通知功能：

一般，web应用要实现通知功能需要使用*websocket*，相比http，前者是全双工的，而后者是响应式的；

但可惜的是，我仅仅是在boost的一些组件中了解过websocket，而go的`net/http`不直接支持websocket；

***

考虑一个http的实时通知，需要客户端定时向服务器发起请求，请求内容是当前用户是否有新的通知。

这样的做法的缺陷是增大了服务端的开销，远远没有websocket的实现优雅；

***

Q: HTTP定时请求与websocket实现的区别？

采用 HTTP 定时请求和 WebSocket 的实现方式各有优缺点，适用于不同的场景。以下是它们之间的主要区别：

### HTTP 定时请求

1. **实现简单**：
   - 使用标准的 HTTP 请求，容易理解和实现。

2. **请求频率**：
   - 客户端定期向服务器发送请求，例如每隔几秒请求一次。这会导致一定的网络开销，尤其是在请求频繁的情况下。

3. **延迟**：
   - 通知的延迟取决于定时请求的频率。用户可能会在一定时间内未能接收到最新通知。

4. **服务器负载**：
   - 服务器需要处理大量的请求，尤其是在用户数量较多时，可能会导致资源消耗增加。

5. **数据流量**：
   - 每次请求都会带上请求头和响应头，可能造成额外的带宽消耗。

### WebSocket

1. **双向通信**：
   - WebSocket 允许客户端和服务器之间的双向通信，服务器可以主动推送通知到客户端，避免轮询。

2. **实时性**：
   - 一旦建立连接，通知可以即时发送，几乎没有延迟，适合需要快速反馈的场景。

3. **连接保持**：
   - WebSocket 连接在整个会话中保持，减少了重复建立连接的开销。

4. **服务器负载**：
   - 尽管 WebSocket 连接的初始建立需要资源，但长期保持连接可以减少请求数量，从而降低总体负载。

5. **复杂性**：
   - 实现相对复杂，需要处理连接的建立、关闭、错误等情况。

### 选择建议

- **如果通知不需要实时更新**，且用户可以接受延迟，HTTP 定时请求可能就足够了。
- **如果需要实时通知**，例如聊天应用、实时数据监控等，WebSocket 是更好的选择。


这里前面写了那么多，升级是不可能升级的了。


## 建表

* notify
  * id(uint32)
  * source_id(uint32)
  * target_id(uint32)
  * comment_id(string)
  * status(string)

## 分析

### 插入

插入一条新评论时，应生成一条通知：

1. `source_id & comment_id`

这两个字段均来自当前要插入的comment记录；

2. `target_id`
   1. 如果父评论是虚拟根节点，那么target_id就是comment当前文章的作者
   2. 否则就是父评论的sender

### 读取

需要返回一段信息

source_name发送了comment在何时何处: 

```sql
select author.name, content, release_time, article_id 
from (
  select source_id, comment_id from notify where target_id = 1 and status = 'unread'
) cur_notify
join author on author.id = source_id
join comment on comment.id = comment_id;
```

服务端返回json即可，这些都是类似的操作。

### 小结

服务端基本写完了，不保证一点bug没有，但至少能跑起来了；

接下来搞搞前端页面就好了，应该是没有精力在做别的了，毕竟花的时间已经够多了。


## 通知页面

考虑每个通知页面该如何组织，首先请求新的通知，直接使用一个`<a>`即可；

感觉服务端不应该返回json，直接返回一个页面多简单(主要我是在写不大了前端)

```go
type NotifyItem struct {
  Id uint32
  Sender string
  Content string
  Release_time string
  ArticleId uint32
}
```

考虑了以下灵活性，还是返回json然后由js处理内容，就不适用模板了，这里用模板的话还要单独在`view`层实现一个接口函数，可能这个函数是有用的，不过我们已经没有多余要实现的内容了。

生成通知列表的步骤类似生成评论。

终于是差不多了，在对一些细节补一补就好了。

# 12 补充

### 路由处理函数

在`hanleHome()`中，不应该判断http请求方法，因此这个函数可能被多个路由处理函数调用，虽然它本身是`GET`：

```go
func RecvNewMdFile(w, r) {
  if (!post) {
    return
  }
  // 保证是 POST 方法

  // ... 处理

  // 响应主页
  handleHome(w, r); 
}
```

上述示例中，如果在`handleHome()`中限定`GET`方法，那么在`RecvNewFile()`的主体可以正常执行，但是最后结果返回一个`405`的状态码，除此以外一切正常，**非常的诡异**。

### 评论的层级设计

这里注意到，如果多次点击展开评论的按钮，会一直向下增加条目，许多条目是重复的，这是不希望的。

我一开始的解决方案是`call_once()`，限制获取评论的方法只能调用一次。

这样做比较简单，但是如果想通过多次获取新的评论就必须刷新整个页面，在评论层级较深的时候比较难用。

后来试了很多，最后决定了一下的方案。

保证每个评论条目(由一个`<li>`描述)的子评论仅有一个`<ul>`描述，这个`<ul>`在父评论`<media-body>`的尾部；

每次调用`fetch()`，如果返回空数组，则什么也不做；

否则用这个返回的数组替换到当前已有的`<ul>`，即如果已有，则移除，然后添加这个新的。

### 服务器优雅退出

总体思路于C/C++的实现差不多，都是注册对应的信号处理函数，

当指定的信号产生后，服务器停止接收新的连接，并等待处理完当前正在执行的任务。

`net/http`包提供了一个`Shutdown()`函数，可以实现上述功能，它接收一个`context.Context`类型的参数。

go语言中的`context`是用来实现`goroutine`生命周期的管理，包括取消请求，参数传递，时间限制等。

比如在当前的实例中，`controller`层和`model`层可以采用`context`作为参数传递，我对这个包目前也不是很熟悉，就不多介绍了。

